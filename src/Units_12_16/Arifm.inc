;=============================================================================
;Арифметические процедуры
;При вызове требует включенности банка, в котором размещены переменные
;=============================================================================

;Перед подключением модуля описать параметры (1=используется, 0=нет):
;#define	Arifm_Mul		1	;Умножение используется
;#define	Arifm_Div		0	;Деление не используется

;===== КОНСТАНТЫ И ПЕРЕМЕННЫЕ ================================================

;Переменные в текущем банке
		CBLOCK
		  MulArg:		1	;Аргумент умножения / Делитель при делении
		  PRODH,PRODL:		1	;Результат умножения / Делимое при делении
		  ArifmTmp:		1	;Временная переменная
		ENDC

	IF (Arifm_Div==1)
		CBLOCK
		  DivResH,DivResL:	1	;Частное деления
		  DivOst:		1	;Остаток деления
		ENDC
	ENDIF

;Двухбайтовые переменные
#define		PROD2		PRODH,PRODL
#define		DivRes2		DivResH,DivResL

;===== УМНОЖЕНИЕ =============================================================

	IF (Arifm_Mul==1)

;Умножение MulArg на W в PROD2. MulArg портит, W не портит.
;Длительность 95 тактов вместе с вызовом
Mul_8x8:	clr2f	PROD2			;Подготовка результата
		clrf	ArifmTmp		;Число циклов = 8 (без изменения W)
		bsf	ArifmTmp,3
_Mul8x8_Next:	clrc				;Сдвиг результата
		rl2f	PROD2				;Бит C после этого всегда равен 0
		If_1	MulArg,7		;Очередной бит = 1 => Прибавление W к результату
		  addwf	PRODL,ToF
		If_C					;Если addwf не было, то C=0 после сдвига PRODH
		  incf	PRODH,ToF			;Бит C не изменяется!
		rlf	MulArg,ToF		;Сдвиг MulArg
		loop_f	ArifmTmp,_Mul8x8_Next	;Зацикливание
		return

	ENDIF

;===== ДЕЛЕНИЕ ===============================================================

	IF (Arifm_Div==1)

;Деление PROD2 (2 байта) на MulArg (1 байт). Результат в DivRes2 (2 байта), остаток в DivOst (1 байт).
;PROD2 портит, MulArg не меняет. При делении на 0 возвращает DivRes2=0xFFFF, DivOst=0 (для корректного округления).
;Длительность max 286 тактов вместе с вызовом
Divide_2To1:	clrf	DivOst			;Дополняем число до DivOst:PROD2 = 00:PROD2
		test_f	MulArg			;Проверка деления на 0
		If_Z
		  goto	_Div_SetDRes2
		mov_lwf	.16,ArifmTmp		;Число бит для деления (разрядность PROD2)
		clr2f	DivRes2			;Подготовка результата
		;Поиск возможности сокращения расчётов
_Div21_Sokr:	If_FB	PRODH,7			;Старший бит PROD2 = 1 => Вылезет в остаток, выход
		  goto	_Div21_Next
		rl2f	PROD2			;Следующий проход деления был бы холостым, просто сдвигаем аргумент
		loop_f	ArifmTmp,_Div21_Sokr	;Число проходов уменьшаем на 1
		return				;Проходы закончились (число было нулевое) => Выход
		;Цикл деления
_Div21_Next:	rl2f	PROD2			;Сдвигаем DivOst:PROD2 влево
		rlf	DivOst,ToF
		If_C
		  goto	_Div21_1		;Иногда может быть 9-й разряд (напр., в прошлый раз было 0x80-0xFF) => можно вычитать
		cmp_fwf	MulArg,DivOst		;Получение DivOst-MulArg
		If_2Lt1				;DivOst<MulArg => Вычесть нельзя, в результат пишем 0 (сейчас C=0)
		  goto	_Div21_2
_Div21_1:	sub_fwf	MulArg,DivOst		;Вычесть можно: вычитаем DivOst:=DivOst-MulArg
		setc					;В результат пишем 1 (C=1)
_Div21_2:	rl2f	DivRes2			;Вписываем очередной бит в результат
		loop_f	ArifmTmp,_Div21_Next
		;Оставшаяся часть в DivOst:PROD2 = DivOst:0000
		return
_Div_SetDRes2:	movlw2f	0xFFFF,DivRes2		;Установка максимального значения DivRes2
		return

	ENDIF

;=============================================================================
