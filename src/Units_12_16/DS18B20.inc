;=============================================================================
;Процедуры для общения с цифровым термометром DS18В20 (также программно совместим с DS1822)
;Все процедуры требуют и возвращают Bank_0!
;=============================================================================

;Модуль подходит для датчиков и с внешним, и с паразитным питанием.
;Модуль рассчитан на подключение только одного датчика на линии (используется "Skip ROM").

;Длительности процедур указаны для 1 MIPS (для 5 MIPS чуть-чуть меньше) и не учитывают
;увеличение времени на обработку прерываний во время их выполнения (если есть).

;Модуль работает при скорости МК от 1 и 5 MIPS. РАБОТА МОДУЛЯ ПРИ 5 MIPS НЕ ПРОВЕРЯЛАСЬ!

;Программное подключение модуля:
;1. Переменные модуля должны находиться в Bank_0.
;2. До подключения модуля описать в программе вывод, к которому подключен датчик:
;	#define		DS18B20_DQ_PORT	PORTA,0		;Линия данных датчика
;	#define		DS18B20_DQ_TRIS	TRISA,0		;Направление линии данных датчика
;3. До подлючения модуля подключить модуль MCUPauses.inc и задать константу MCU_Speed (см. модуль).
;4. Все процедуры могут запрещать прерывания на время от 12 до 67-74 мкс. Программа должна быть
;   организована соответственно. Допускается работа модуля при запрещённых прерываниях.
;5. В начале работы вызвать макрос DS18B20Init (если питание датчика отключается, то вызывать
;   после каждого включения питания).
;6. При необходимости задать разрешение одним из макросов DS18B20Set**bit

;Формат результата DS18B20_T - [°C]*16 со знаком:
;S S S S S T6 T5 T4  |  T3 T2 T1 T0 T-1 T-2 T-3 T-4

;===== КОНСТАНТЫ И ПЕРЕМЕННЫЕ ================================================

;Переменные
		CBLOCK
		  DS18B20_Flags:		1	;Флаги
		  DS18B20_TH,DS18B20_TL:	1	;Температура в формате датчика
		  DS18B20_Tmp1,DS18B20_Tmp2:	1	;Временные переменные
		ENDC

;Флаги переменной DS18B20_Flags
#define		DS18B20_IsIntrs	DS18B20_Flags,0		;Прерывания в программе были разрешены
#define		DS18B20_Present	DS18B20_Flags,1		;Датчик присутствует на линии (0=нет)

;Двухбайтовые переменные
#define		DS18B20_T	DS18B20_TH,DS18B20_TL

;===== ПРОЦЕДУРЫ И ФУНКЦИИ ===================================================

;Инициализация. Вызывается один раз в начале работы. Заполняет DS18B20_Present.
;Длительность более 980 мкс, запрещает прерывания примерно на 67-74 мкс
#define		DS18B20Init		call	DS18B20_Setup_

;Задание разрядности преобразования. Заполняет DS18B20_Present.
;Вызывать до запуска преобразования.
;Длительность до 4530 мкс, запрещает прерывания на отрезки до 67-74 мкс
#define		DS18B20Set9bit		call	DS18B20_9bit_		;9 бит  (0.5 °C, преобразование 93.75 мс)
#define		DS18B20Set10bit		call	DS18B20_10bit_		;10 бит (0.25 °C, преобразование 187.5 мс)
#define		DS18B20Set11bit		call	DS18B20_11bit_		;11 бит (0.125 °C, преобразование 375 мс)
#define		DS18B20Set12bit		call	DS18B20_12bit_		;12 бит (0.0625 °C, преобразование 750 мс)
;По умолчанию после включения питания задано разрешение 12 бит

;Запуск измерения температуры. Заполняет DS18B20_Present.
;После вызова процедуры преобразование идёт длительное время (см. шапку модуля).
;Длительность до 2400 мкс, запрещает прерывания на отрезки до 67-74 мкс
#define		DS18B20ConvertT		call	DS18B20_ConvT_

;Чтение результата преобразования без ожидания в DS18B20_T. Заполняет DS18B20_Present.
;После включения питания (до первого преобразования) считывается значение 0x0550.
;После запуска преобразования к моменту вызова процедуры преобразование должно быть полностью завершено.
;При отказе датчика значение DS18B20_T не меняется.
;Длительность до 3620 мкс, запрещает прерывания на отрезки до 67-74 мкс
#define		DS18B20ReadT		call	DS18B20_ReadT_

;===== РЕАЛИЗАЦИЯ ============================================================

DS18B20_Setup_:	clrf	DS18B20_Flags		;Очистка флагов
		goto	_DS18B20_Init		;Инициализация обмена (более 980 мкс) и выход (return там)

DS18B20_9bit_:	call	_DS18B20_Init		;Инициализация обмена (более 980 мкс)
		If_0	DS18B20_Present		;Датчика нет или ошибка => Выход
		  return
		movlw	0xCC			;ROM Command 0xCC - "Skip ROM" (до 706 мкс)
		call	_DS18B20_SendW
		movlw	0x4E			;Function Command 0x4E - "Write Scratchpad" (до 706 мкс)
		call	_DS18B20_SendW
		movlw	0x7F			;Задание TH = 0x7F (до 706 мкс)
		call	_DS18B20_SendW
		movlw	0x80			;Задание TL = 0x80 (до 706 мкс)
		call	_DS18B20_SendW
		movlw	0x1F			;Задание configuration register = 0x1F - 9 бит (до 706 мкс)
		goto	_DS18B20_SendW			;(return там)

DS18B20_10bit_:	call	_DS18B20_Init		;Инициализация обмена (более 980 мкс)
		If_0	DS18B20_Present		;Датчика нет или ошибка => Выход
		  return
		movlw	0xCC			;ROM Command 0xCC - "Skip ROM" (до 706 мкс)
		call	_DS18B20_SendW
		movlw	0x4E			;Function Command 0x4E - "Write Scratchpad" (до 706 мкс)
		call	_DS18B20_SendW
		movlw	0x7F			;Задание TH = 0x7F (до 706 мкс)
		call	_DS18B20_SendW
		movlw	0x80			;Задание TL = 0x80 (до 706 мкс)
		call	_DS18B20_SendW
		movlw	0x3F			;Задание configuration register = 0x3F - 10 бит (до 706 мкс)
		goto	_DS18B20_SendW			;(return там)

DS18B20_11bit_:	call	_DS18B20_Init		;Инициализация обмена (более 980 мкс)
		If_0	DS18B20_Present		;Датчика нет или ошибка => Выход
		  return
		movlw	0xCC			;ROM Command 0xCC - "Skip ROM" (до 706 мкс)
		call	_DS18B20_SendW
		movlw	0x4E			;Function Command 0x4E - "Write Scratchpad" (до 706 мкс)
		call	_DS18B20_SendW
		movlw	0x7F			;Задание TH = 0x7F (до 706 мкс)
		call	_DS18B20_SendW
		movlw	0x80			;Задание TL = 0x80 (до 706 мкс)
		call	_DS18B20_SendW
		movlw	0x5F			;Задание configuration register = 0x5F - 11 бит (до 706 мкс)
		goto	_DS18B20_SendW			;(return там)

DS18B20_12bit_:	call	_DS18B20_Init		;Инициализация обмена (более 980 мкс)
		If_0	DS18B20_Present		;Датчика нет или ошибка => Выход
		  return
		movlw	0xCC			;ROM Command 0xCC - "Skip ROM" (до 706 мкс)
		call	_DS18B20_SendW
		movlw	0x4E			;Function Command 0x4E - "Write Scratchpad" (до 706 мкс)
		call	_DS18B20_SendW
		movlw	0x7F			;Задание TH = 0x7F (до 706 мкс)
		call	_DS18B20_SendW
		movlw	0x80			;Задание TL = 0x80 (до 706 мкс)
		call	_DS18B20_SendW
		movlw	0x7F			;Задание configuration register = 0x7F - 12 бит (до 706 мкс)
		goto	_DS18B20_SendW			;(return там)

DS18B20_ConvT_:	call	_DS18B20_Init		;Инициализация обмена (более 980 мкс)
		If_0	DS18B20_Present		;Датчика нет или ошибка => Выход
		  return
		movlw	0xCC			;ROM Command 0xCC - "Skip ROM" (до 706 мкс)
		call	_DS18B20_SendW
		movlw	0x44			;Function Command 0x44 - "Convert T" (до 706 мкс)
		goto	_DS18B20_SendW			;(return там)

DS18B20_ReadT_:	call	_DS18B20_Init		;Инициализация обмена (более 980 мкс)
		If_0	DS18B20_Present		;Датчика нет или ошибка => Выход
		  return
		movlw	0xCC			;ROM Command 0xCC - "Skip ROM" (до 706 мкс)
		call	_DS18B20_SendW
		movlw	0xBE			;Function Command 0xBE - "Read Scratchpad" (до 706 мкс)
		call	_DS18B20_SendW
		call	_DS18B20_RecW		;Чтение байта Temperature LSB в W и DS18B20_TL (610 мкс)
		movwf	DS18B20_TL
		call	_DS18B20_RecW		;Чтение байта Temperature MSB в W и DS18B20_TH (610 мкс)
		movwf	DS18B20_TH
		return

;===== СЛУЖЕБНЫЕ ПРОЦЕДУРЫ ===================================================

;При адаптации программы для другого быстродействия менять только процедуры пауз в модуле MCUPauses.inc!
;При частотах выше ниже 1 MIPS и 5 MIPS проверять ограничения макроса MCUPause_mks!

;***** Процедуры обмена *****

;Инициализация обмена по шине. Заполняет DS18B20_Present
;Длительность более 980 мкс, из них примерно в середине запрещает прерывания примерно на 67-74 мкс
_DS18B20_Init:	bcf	DS18B20_IsIntrs		;Сохранение GIE в DS18B20_IsIntrs
		If_1	INTCON,GIE
		  bsf	DS18B20_IsIntrs
		bcf	DS18B20_DQ_PORT		;Сигнал для импульса
		Bank_0To1
		bcf	DS18B20_DQ_TRIS		;Вывод в состояние "Выход"
		MCUPause_mks .200		;Пауза 480 мкс (минимум)
		MCUPause_mks .200
		MCUPause_mks .80
		bcf	INTCON,GIE		;Запрет прерываний (до снятия DS18B20_DQ!)
		bsf	DS18B20_DQ_TRIS		;Вывод в состояние "Вход"
		Bank_1To0
		MCUPause_mks .66		;Пауза 66 мкс ровно
		If_1	DS18B20_DQ_PORT		;Датчик не ответил => Ошибка
		  goto	_DS18B20_I_Err
		If_1	DS18B20_IsIntrs		;Разрешение прерываний (возврат DS18B20_IsIntrs в GIE)
		  bsf	INTCON,GIE
		MCUPause_mks .200		;Пауза 480-66=414 мкс (минимум)
		MCUPause_mks .200
		MCUPause_mks .14
		If_0	DS18B20_DQ_PORT		;Линия остаётся в нуле => Ошибка
		  goto	_DS18B20_I_Err
		bsf	DS18B20_Present		;Флаг - датчик есть и готов
		return
_DS18B20_I_Err:	;Датчик неисправен
		If_1	DS18B20_IsIntrs		;Разрешение прерываний (возврат DS18B20_IsIntrs в GIE)
		  bsf	INTCON,GIE
		bcf	DS18B20_Present		;Флаг - датчика нет
		return

;Посыл байта из W
;Длительность до 706 мкс, несколько раз запрещает прерывания примерно на 12 или 66 мкс
_DS18B20_SendW:	movwf	DS18B20_Tmp1		;Сохранение значения
		bcf	DS18B20_IsIntrs		;Сохранение GIE в DS18B20_IsIntrs
		If_1	INTCON,GIE
		  bsf	DS18B20_IsIntrs
		bcf	DS18B20_DQ_PORT		;Сигнал для импульсов
		mov_lwf	.8,DS18B20_Tmp2		;Число бит
_DS18B20_SW_1:	rrf	DS18B20_Tmp1,ToF	;Сдвиг данных, текущий бит в C
		If_C				;Переход к передаче бита из C
		  goto	_DS18B20_SW_S1
_DS18B20_SW_S0:	;Отправка нуля (Write 0 time slot + пауза минимум 1 мкс)
		bcf	INTCON,GIE		;Запрет прерываний (обязательно, чтобы импульс не превысил 480 мкс!)
		Bank_0To1
		bcf	DS18B20_DQ_TRIS		;Вывод в состояние "Выход"
		MCUPause_mks .60		;Пауза 60 мкс (минимум, максимум 120 мкс)
		bsf	DS18B20_DQ_TRIS		;Вывод в состояние "Вход"
		Bank_1To0
		If_1	DS18B20_IsIntrs		;Разрешение прерываний (возврат DS18B20_IsIntrs в GIE)
		  bsf	INTCON,GIE
		MCUPause_mks .12		;Пауза между слотами минимум 10 мкс (беру 12, т.к. кратно 4)
		goto	_DS18B20_SW_SE
_DS18B20_SW_S1:	;Отправка единицы (Write 1 time slot + пауза минимум 1 мкс)
		bcf	INTCON,GIE		;Запрет прерываний
		Bank_0To1
		bcf	DS18B20_DQ_TRIS		;Вывод в состояние "Выход"
		MCUPause_6mks			;Пауза 6 мкс (треб. минимум 1 и максимум 15 мкс)
		bsf	DS18B20_DQ_TRIS		;Вывод в состояние "Вход"
		Bank_1To0
		If_1	DS18B20_IsIntrs		;Разрешение прерываний (возврат DS18B20_IsIntrs в GIE)
		  bsf	INTCON,GIE
		MCUPause_mks .64		;Пауза минимум 70-6=64 мкс (слот минимум 60 мкс + между слотами минимум 10 мкс)
_DS18B20_SW_SE:	;Бит отправлен, зацикливание
		loop_f	DS18B20_Tmp2,_DS18B20_SW_1
		return
;Пауза между слотами минимум 1 мкс, но беру минимум 10 мкс, т.к. за 1 мкс линия может не успеть восстановиться

;Приём байта в W
;Длительность 610 мкс, несколько раз запрещает прерывания примерно на 17 мкс
_DS18B20_RecW:	bcf	DS18B20_IsIntrs		;Сохранение GIE в DS18B20_IsIntrs
		If_1	INTCON,GIE
		  bsf	DS18B20_IsIntrs
		bcf	DS18B20_DQ_PORT		;Сигнал для импульсов
		mov_lwf	.8,DS18B20_Tmp2		;Число бит
_DS18B20_RW_1:	;Чтение очередного бита
		bcf	INTCON,GIE		;Запрет прерываний
		Bank_0To1
		bcf	DS18B20_DQ_TRIS		;Вывод в состояние "Выход"
		MCUPause_1mks			;Пауза 1 мкс (минимум, рекомендуется не больше)
		bsf	DS18B20_DQ_TRIS		;Вывод в состояние "Вход"
		Bank_1To0
		MCUPause_6mks			;Пауза 6 мкс (максимум 15-1=14, минимум - чтобы линия восстановилась)
		movfbc	DS18B20_DQ_PORT		;Чтение бита в C (3 такта)
		rrf	DS18B20_Tmp1,ToF	;Сдвиг данных, текущий бит из C в DS18B20_Tmp1
		If_1	DS18B20_IsIntrs		;Разрешение прерываний (возврат DS18B20_IsIntrs в GIE)
		  bsf	INTCON,GIE
		MCUPause_mks .52		;Пауза минимум 61-1-6=54 мкс (слот 60 мкс + между слотами минимум 1 мкс)
		MCUPause_2mks
		;Бит получен, зацикливание
		loop_f	DS18B20_Tmp2,_DS18B20_RW_1
		mov_fw	DS18B20_Tmp1		;Загрузка значения в W из DS18B20_Tmp1
		return

;=============================================================================
